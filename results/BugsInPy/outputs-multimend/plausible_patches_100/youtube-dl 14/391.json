{
  "correct": false,
  "plausible": true,
  "hunks": [
    {
      "hunk": 0,
      "source": "",
      "patch": "",
      "target": "def _extract_chapters_from_json(self, webpage, video_id, duration): if not webpage: return player = self._parse_json( self._search_regex( r'RELATED_PLAYER_ARGS[\"\\']\\s*:\\s*({.+})\\s*,?\\s*\\n', webpage, 'player args', default='{}'), video_id, fatal=False) if not player or not isinstance(player, dict): return watch_next_response = player.get('watch_next_response') if not isinstance(watch_next_response, compat_str): return response = self._parse_json(watch_next_response, video_id, fatal=False) if not response or not isinstance(response, dict): return chapters_list = try_get( response, lambda x: x['playerOverlays'] ['playerOverlayRenderer'] ['decoratedPlayerBarRenderer'] ['decoratedPlayerBarRenderer'] ['playerBar'] ['chapteredPlayerBarRenderer'] ['chapters'], list) if not chapters_list: return  def chapter_time(chapter): return float_or_none( try_get( chapter, lambda x: x['chapterRenderer']['timeRangeStartMillis'], int), scale=1000) chapters = [] for next_num, chapter in enumerate(chapters_list, start=1): start_time = chapter_time(chapter) if start_time is None: continue end_time = (chapter_time(chapters_list[next_num]) if next_num < len(chapters_list) else duration) if end_time is None: continue title = try_get( chapter, lambda x: x['chapterRenderer']['title']['simpleText'], compat_str) chapters.append({ 'start_time': start_time, 'end_time': end_time, 'title': title, }) return chapters",
      "exact_match": false
    },
    {
      "hunk": 1,
      "source": "def _extract_chapters(description, duration):",
      "patch": "def _extract_chapters_from_description(description, duration):",
      "target": "def _extract_chapters_from_description(description, duration):",
      "exact_match": true
    },
    {
      "hunk": 2,
      "source": "",
      "patch": "",
      "target": "def _extract_chapters(self, webpage, description, video_id, duration): return (self._extract_chapters_from_json(webpage, video_id, duration) or self._extract_chapters_from_description(description, duration))",
      "exact_match": false
    },
    {
      "hunk": 3,
      "source": "chapters = self._extract_chapters(description_original, video_duration)",
      "patch": "chapters = self._extract_chapters(description_original, video_duration)",
      "target": "chapters = self._extract_chapters(video_webpage, description_original, video_id, video_duration)",
      "exact_match": false
    }
  ]
}